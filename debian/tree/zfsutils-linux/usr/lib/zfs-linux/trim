#!/bin/sh -eu

# directly exit successfully when zfs module is not loaded
if ! [ -d /sys/module/zfs ]; then
	exit 0
fi

# [auto] / enable / disable
PROPERTY_NAME="org.debian:periodic-trim"

get_property () {
	# Detect the ${PROPERTY_NAME} property on a given pool.
	# We are abusing user-defined properties on the root dataset,
	# since they're not available on pools https://github.com/openzfs/zfs/pull/11680
	# TODO: use zpool user-defined property when such feature is available.
	pool="$1"
	zfs get -H -o value "${PROPERTY_NAME}" "${pool}" 2>/dev/null || return 1
}

trim_if_not_already_trimming () {
	pool="$1"
	if ! zpool status "${pool}" | grep -q "trimming"; then
		# Ignore errors (i.e. HDD pools),
		# and continue with trimming other pools.
		zpool trim "${pool}" || true
	fi
}

zpool_is_nvme_only () {
	zpool=$1
	# get a list of devices attached to the specified zpool
	zpool list -vHPL ${zpool} | awk '/\/dev\//{print $1}' \
		| while read dev
		do
			# are these devices all nvme drives?
			if !(echo ${dev} | grep -q /dev/nvme); then
				return 1
			fi
		done
	return 0
}

# TRIM all healthy pools that are not already trimming as per their configs.
zpool list -H -o health,name 2>&1 | \
	awk '$1 ~ /^ONLINE/ { print $2; }' | \
while read pool
do
	# read user-defined config
	ret=$(get_property "${pool}")
	if [ $? -ne 0 ] || [ "disable" = "${ret}" ]; then
		continue
	elif [ "enable" = "${ret}" ]; then
		trim_if_not_already_trimming "${pool}"
	elif [ "-" = "${ret}" ] || [ "auto" = "${ret}" ]; then
		# only automatically trim the nvme-only pools.
		zpool_is_nvme_only "${pool}" \
			&& trim_if_not_already_trimming "${pool}" \
			|| continue
	else
		cat > /dev/stderr <<EOF
/usr/lib/zfs-linux/trim: [WARNING] illegal value "${ret}" for property "${PROPERTY_NAME}" of ZFS dataset "${pool}".
/usr/lib/zfs-linux/trim: Acceptable choices for this property are: auto, enable, disable. The default is auto.
EOF
	fi
done
